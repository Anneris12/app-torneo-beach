<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Prode ‚Äì Beach Volley 2026</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0e1f3b;
      --card: #0f2446;
      --accent: #ffb703;
      --accent-2: #3fd1c2;
      --text: #e8edf5;
      --muted: #d9e4ff;
      --locked: #cbd5e1;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at 20% 20%, rgba(63, 209, 194, 0.25), rgba(14, 31, 59, 0.9)),
                  radial-gradient(circle at 80% 0%, rgba(255, 183, 3, 0.18), rgba(14, 31, 59, 1));
      color: var(--text);
      min-height: 100vh;
      padding: 20px 14px 60px;
    }

    h1 {
      text-align: center;
      font-weight: 800;
      letter-spacing: 0.4px;
      margin-bottom: 6px;
    }

    h2 {
      margin: 0 0 10px;
      font-size: 18px;
    }

    p {
      margin: 0;
    }

    .page-description {
      text-align: center;
      color: var(--muted);
      margin-bottom: 18px;
      font-size: 14px;
    }

    .grid-menu {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
      gap: 14px;
      margin: 14px 0 30px;
    }

    .card {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.22);
    }

    .nav-card {
      display: grid;
      grid-template-columns: 48px 1fr;
      gap: 12px;
      align-items: center;
      cursor: pointer;
      transition: transform 0.15s ease, border-color 0.15s ease;
      text-decoration: none;
      color: var(--text);
    }

    .nav-card:hover {
      transform: translateY(-2px);
      border-color: rgba(255,255,255,0.35);
    }

    .nav-icon {
      width: 48px;
      height: 48px;
      border-radius: 14px;
      background: rgba(63, 209, 194, 0.14);
      display: grid;
      place-items: center;
      font-size: 24px;
    }

    .nav-body {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .nav-title {
      font-weight: 700;
    }

    .nav-sub {
      color: var(--muted);
      font-size: 13px;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 30px;
      font-size: 12px;
      font-weight: 700;
    }

    .badge-open { background: rgba(63, 209, 194, 0.14); color: #5cf2e1; }
    .badge-closed { background: rgba(255, 99, 71, 0.12); color: #ff8c7a; }
    .badge-blocked { background: rgba(160, 174, 192, 0.16); color: #cbd5e0; }

    .section {
      margin-bottom: 26px;
    }

    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }

    .section-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .btn {
      border: none;
      background: var(--accent);
      color: #0e1f3b;
      font-weight: 700;
      padding: 10px 14px;
      border-radius: 12px;
      cursor: pointer;
      transition: opacity 0.2s ease, transform 0.15s ease;
    }

    .btn:hover { opacity: 0.92; }
    .btn:active { transform: translateY(1px); }

    .btn-secondary {
      background: rgba(255,255,255,0.08);
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.12);
    }

    .btn-ghost {
      background: transparent;
      color: var(--muted);
      border: 1px dashed rgba(255,255,255,0.2);
    }

    .pill-switch {
      display: inline-flex;
      gap: 6px;
      padding: 4px;
      background: rgba(255,255,255,0.06);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
    }

    .pill-switch button {
      border: none;
      background: transparent;
      color: var(--muted);
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
    }

    .pill-switch button.active {
      background: var(--accent);
      color: #0e1f3b;
    }

    .match-card {
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 12px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      position: relative;
    }

    .match-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      color: var(--muted);
      font-size: 13px;
    }

    .team-row {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 10px;
      background: rgba(255,255,255,0.05);
      padding: 8px 10px;
      border-radius: 10px;
    }

    .team-name { font-weight: 700; }

    .select-btn {
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(255,255,255,0.08);
      color: var(--text);
      border-radius: 10px;
      padding: 6px 10px;
      font-weight: 700;
      cursor: pointer;
      transition: background 0.15s ease, transform 0.1s ease;
    }

    .select-btn.selected {
      background: var(--accent);
      color: #0e1f3b;
      border-color: var(--accent);
    }

    .select-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .locked {
      opacity: 0.7;
    }

    .locked-label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: var(--locked);
      font-weight: 700;
      font-size: 13px;
    }

    .locked-label span {
      font-size: 18px;
    }

    .ribbon {
      position: absolute;
      top: 12px;
      right: 12px;
      padding: 6px 8px;
      font-size: 12px;
      border-radius: 10px;
      background: rgba(255,255,255,0.08);
      color: var(--muted);
    }

    .list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .status-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 12px;
      background: rgba(255,255,255,0.08);
      color: var(--muted);
      font-weight: 700;
      font-size: 13px;
    }

    .summary-box {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 12px;
      margin-top: 10px;
    }

    .mini-card {
      background: rgba(255,255,255,0.05);
      border: 1px dashed rgba(255,255,255,0.08);
      padding: 12px;
      border-radius: 12px;
    }

    .mini-title {
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.4px;
      margin-bottom: 4px;
    }

    .mini-value {
      font-size: 22px;
      font-weight: 800;
    }

    .notice {
      font-size: 13px;
      color: var(--muted);
      margin-top: 8px;
    }

    .ranking-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 10px;
    }

    .ranking-row {
      display: grid;
      grid-template-columns: 40px 1fr auto;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: rgba(255,255,255,0.04);
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.08);
    }

    .ranking-row.me {
      border-color: var(--accent);
      background: rgba(255, 183, 3, 0.12);
      color: #0e1f3b;
    }

    .label-muted { color: var(--muted); }

    .login-panel {
      max-width: 520px;
      margin: 0 auto 20px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.1);
      padding: 20px;
      border-radius: 18px;
      box-shadow: 0 15px 35px rgba(0,0,0,0.24);
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-bottom: 12px;
    }

    label { font-weight: 700; }

    input {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(255,255,255,0.08);
      color: var(--text);
      font-size: 14px;
    }

    .helper { color: var(--muted); font-size: 13px; }

    .hidden { display: none !important; }

    @media (max-width: 720px) {
      body { padding: 16px 12px 80px; }
      .grid-menu { grid-template-columns: 1fr; }
      .match-card { padding: 12px 10px; }
    }
  </style>
</head>
<body>
  <h1>Prode ‚Äì Beach Volley 2026</h1>
  <p class="page-description">Registra tu alias, carg√° pron√≥sticos y segu√≠ tu puntaje por etapas.</p>

  <div id="loginPanel" class="login-panel">
    <h2>Crear / Ingresar a mi Prode</h2>
    <p class="helper">Guardamos tu alias y DNI para que puedas volver a entrar con el mismo perfil.</p>
    <div class="field">
      <label for="aliasInput">Alias</label>
      <input id="aliasInput" type="text" placeholder="Ej: Maca #123" />
    </div>
    <div class="field">
      <label for="dniInput">DNI o √∫ltimos 4 d√≠gitos</label>
      <input id="dniInput" type="text" placeholder="0000" />
      <p class="helper">El DNI se usa solo para identificar al ganador.</p>
    </div>
    <div class="section-actions">
      <button id="createUser" class="btn">Continuar</button>
    </div>
  </div>

  <div id="homeSection" class="hidden">
    <div class="grid-menu">
      <div class="card nav-card" data-target="stage1">
        <div class="nav-icon">üèê</div>
        <div class="nav-body">
          <div class="nav-title">Etapa 1 ‚Äì Grupos</div>
          <div class="nav-sub">Complet√° hasta el inicio de cada partido.</div>
          <div class="badge" id="badgeStage1"></div>
        </div>
      </div>

      <div class="card nav-card" data-target="stage2">
        <div class="nav-icon">üèÜ</div>
        <div class="nav-body">
          <div class="nav-title">Etapa 2 ‚Äì Llaves</div>
          <div class="nav-sub">Eleg√≠ ganadores ronda por ronda.</div>
          <div class="badge" id="badgeStage2"></div>
        </div>
      </div>

      <div class="card nav-card" data-target="scores">
        <div class="nav-icon">üìä</div>
        <div class="nav-body">
          <div class="nav-title">Mi puntaje</div>
          <div class="nav-sub">Etapas y total actualizado.</div>
          <div class="badge badge-open" id="userAlias">Mi Prode</div>
        </div>
      </div>

      <div class="card nav-card" data-target="ranking">
        <div class="nav-icon">ü•á</div>
        <div class="nav-body">
          <div class="nav-title">Ranking general</div>
          <div class="nav-sub">Alias destacados y puntos.</div>
          <div class="badge badge-open">Ver tabla</div>
        </div>
      </div>
    </div>
  </div>

  <div id="stage1" class="section hidden">
    <div class="card">
      <div class="section-header">
        <div>
          <h2>Pron√≥sticos ‚Äì Fase de grupos</h2>
          <p class="helper">Eleg√≠ ganadores por rama. Los partidos en juego o finalizados aparecen bloqueados.</p>
        </div>
        <div class="section-actions">
          <div class="pill-switch" id="branchSwitch1"></div>
          <div id="stage1State" class="status-chip"></div>
        </div>
      </div>

      <div class="list" id="stage1List"></div>
      <div class="notice">Las modificaciones son posibles antes del inicio de cada partido.</div>
      <div class="section-actions" style="margin-top: 14px;">
        <button id="saveStage1" class="btn">Guardar pron√≥sticos de esta rama</button>
        <button class="btn btn-secondary" data-target="home">Volver al home</button>
      </div>
    </div>
  </div>

  <div id="stage2" class="section hidden">
    <div class="card">
      <div class="section-header">
        <div>
          <h2>Pron√≥sticos ‚Äì Llaves</h2>
          <p class="helper">Eleg√≠ ganadores por ronda. El cuadro se habilita al terminar la fase de grupos.</p>
        </div>
        <div class="section-actions">
          <div class="pill-switch" id="branchSwitch2"></div>
          <div id="stage2State" class="status-chip"></div>
        </div>
      </div>
      <div id="stage2Content" class="list"></div>
      <div class="notice">Mientras los partidos no hayan comenzado, pod√©s volver atr√°s y editar.</div>
      <div class="section-actions" style="margin-top: 14px;">
        <button id="saveStage2" class="btn">Guardar llaves</button>
        <button class="btn btn-secondary" data-target="home">Volver al home</button>
      </div>
    </div>
  </div>

  <div id="scores" class="section hidden">
    <div class="card">
      <div class="section-header">
        <div>
          <h2>Mi puntaje</h2>
          <p class="helper">Actualizado al √∫ltimo c√°lculo.</p>
        </div>
        <div class="section-actions">
          <div class="status-chip" id="rankingPosition"></div>
        </div>
      </div>
      <div class="summary-box">
        <div class="mini-card">
          <div class="mini-title">Etapa 1 ‚Äì Grupos</div>
          <div class="mini-value" id="pointsStage1">0 pts</div>
        </div>
        <div class="mini-card">
          <div class="mini-title">Etapa 2 ‚Äì Llaves</div>
          <div class="mini-value" id="pointsStage2">0 pts</div>
        </div>
        <div class="mini-card">
          <div class="mini-title">Total</div>
          <div class="mini-value" id="pointsTotal">0 pts</div>
        </div>
      </div>
      <p class="notice">Las modificaciones de partidos solo son posibles antes del inicio de cada partido.</p>
    </div>
  </div>

  <div id="ranking" class="section hidden">
    <div class="card">
      <div class="section-header">
        <div>
          <h2>Ranking general</h2>
          <p class="helper">Ordenado por puntos totales. Tu usuario se resalta autom√°ticamente.</p>
        </div>
      </div>
      <div class="ranking-list" id="rankingList"></div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-app.js";
    import {
      getFirestore,
      collection,
      doc,
      addDoc,
      getDocs,
      onSnapshot,
      query,
      setDoc,
      updateDoc,
      where,
      getDoc,
      orderBy
    } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore.js";
    import {
      getAuth,
      signInAnonymously,
      onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-auth.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCDLMrgeu3pNs-hOM1vf006wMzWPqfQ_lQ",
      authDomain: "torneo-beach.firebaseapp.com",
      projectId: "torneo-beach",
      storageBucket: "torneo-beach.firebasestorage.app",
      messagingSenderId: "21136645638",
      appId: "1:21136645638:web:52c3b06affc2ee151eed87"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);
    const usersCollection = collection(db, 'prodeUsers');
    const predictionsCollection = collection(db, 'prodePredictions');
    const rankingCollection = collection(db, 'prodeRanking');

    let authReady = false;
    let authUnavailable = false;

    let stageStatus = {
      etapa1: 'bloqueada',
      etapa2: 'bloqueada'
    };

    async function ensureAuth() {
      if (authUnavailable) return null;
      if (authReady && auth.currentUser) return auth.currentUser;
      try {
        const user = await signInAnonymously(auth);
        authReady = true;
        return user;
      } catch (error) {
        authUnavailable = true;
        console.warn('No se pudo autenticar de forma an√≥nima, se contin√∫a sin login.', error);
        return null;
      }
    }

    onAuthStateChanged(auth, user => {
      if (user) authReady = true;
    });

    let stage1Matches = [];

    let stage2Rounds = {
      FEM: {},
      MASC: {}
    };

    let currentUser = null;
    let currentBranch1 = 'FEM';
    let currentBranch2 = 'FEM';
    let predictionsCache = {};

    const branchLabels = { FEM: 'Femenino', MASC: 'Masculino' };

    const badgeStage1 = document.getElementById('badgeStage1');
    const badgeStage2 = document.getElementById('badgeStage2');
    const stage1List = document.getElementById('stage1List');
    const stage2Content = document.getElementById('stage2Content');

    function normalizeRama(raw) {
      const val = (raw || '').toString().toUpperCase();
      if (val.startsWith('F')) return 'FEM';
      if (val.startsWith('M')) return 'MASC';
      return val || 'FEM';
    }

    function normalizeEstado(estado, status) {
      const val = (estado || '').toString().toLowerCase();
      if (val.includes('final')) return 'finalizado';
      if (val.includes('juego')) return 'enjuego';
      if (val.includes('pend')) return 'pendiente';

      const st = (status || '').toString().toLowerCase();
      if (st === 'finished') return 'finalizado';
      if (st === 'in_progress') return 'enjuego';
      return 'pendiente';
    }

    function buildSlotLabel(sourceFrom, sourceResult) {
      if (!sourceFrom) return '';
      const isLoser = (sourceResult || '').toString().toLowerCase().includes('lose');
      const prefix = isLoser ? 'Perdedor' : 'Ganador';
      return `${prefix} ${sourceFrom}`;
    }

    function mapRoundKey(label) {
      const val = (label || '').toString().toLowerCase();
      if (val.includes('final')) return 'Final';
      if (val.includes('semi')) return 'Semi';
      if (val.includes('cuarto') || val.includes('2da') || val.includes('2¬∞')) return 'R2';
      return 'R1';
    }

    function computeWinnerFromSets(data) {
      const sets = Array.isArray(data.setsData) ? data.setsData : [];
      let wins1 = 0;
      let wins2 = 0;

      sets.forEach(set => {
        const a = Number(set.local);
        const b = Number(set.visitante);
        if (a > b) wins1++;
        else if (b > a) wins2++;
      });

      if (wins1 === wins2) return null;
      return wins1 > wins2
        ? (data.team1Name || data.localName || '')
        : (data.team2Name || data.visitanteName || '');
    }

    function updateStageStatusFromGroups() {
      const anyEditable = stage1Matches.some(m => m.estado !== 'finalizado');
      const allFinished = stage1Matches.length > 0 && stage1Matches.every(m => m.estado === 'finalizado');
      stageStatus.etapa1 = anyEditable ? 'abierta' : 'cerrada';
      stageStatus.etapa2 = allFinished ? 'abierta' : 'bloqueada';
      renderBadges();
      renderStage2();
    }

    function attachStage1Listener() {
      const q = query(collection(db, 'matches'), where('phase', '==', 'zonas'));
      onSnapshot(q, snap => {
        stage1Matches = [];
        snap.forEach(docSnap => {
          const d = docSnap.data();
          const rama = normalizeRama(d.categoria || d.category || d.rama);
          const estado = normalizeEstado(d.estado, d.status);
          stage1Matches.push({
            matchId: docSnap.id,
            rama,
            ronda: d.roundLabel || d.ronda || '',
            zona: d.zona || d.zone || '',
            cancha: d.cancha || '',
            hora: d.hora || '',
            equipo1: d.localName || d.team1Name || '',
            equipo2: d.visitanteName || d.team2Name || '',
            estado,
            resultadoReal: d.winnerName || d.resultadoReal || computeWinnerFromSets(d) || null
          });
        });
        updateStageStatusFromGroups();
        renderStage1();
        renderScores();
      });
    }

    function attachStage2Listener() {
      const q = query(collection(db, 'matches'), where('phase', '==', 'maindraw'));
      onSnapshot(q, snap => {
        stage2Rounds = { FEM: {}, MASC: {} };
        snap.forEach(docSnap => {
          const d = docSnap.data();
          const rama = normalizeRama(d.categoria || d.category || d.rama);
          const roundKey = mapRoundKey(d.roundLabel || d.fase || '');
          if (!stage2Rounds[rama][roundKey]) stage2Rounds[rama][roundKey] = [];
          const estado = normalizeEstado(d.estado, d.status);
          const resultadoReal = d.winnerName || d.resultadoReal || computeWinnerFromSets(d) || null;

          stage2Rounds[rama][roundKey].push({
            matchId: docSnap.id,
            ronda: roundKey,
            label: d.drawMatchNumber ? `P${d.drawMatchNumber}` : (d.roundLabel || 'Partido'),
            equipo1: d.team1Name || d.localName || buildSlotLabel(d.slot1SourceFrom, d.slot1SourceResult),
            equipo2: d.team2Name || d.visitanteName || buildSlotLabel(d.slot2SourceFrom, d.slot2SourceResult),
            estado,
            resultadoReal
          });
        });
        renderStage2();
        renderScores();
      });
    }

    function saveUser(user) {
      localStorage.setItem('prodeUser', JSON.stringify(user));
    }

    function loadUser() {
      const raw = localStorage.getItem('prodeUser');
      if (!raw) return null;
      try {
        return JSON.parse(raw);
      } catch (e) {
        return null;
      }
    }

    async function findExistingUser(dniRef) {
      const q = query(usersCollection, where('dniRef', '==', dniRef));
      const snap = await getDocs(q);
      if (snap.empty) return null;
      const docSnap = snap.docs[0];
      return { userId: docSnap.id, ...docSnap.data() };
    }

    async function upsertUser(alias, dniRef) {
      await ensureAuth();
      const now = new Date().toISOString();
      const existing = await findExistingUser(dniRef);
      if (existing) {
        if (existing.alias !== alias) {
          const ref = doc(db, 'prodeUsers', existing.userId);
          await updateDoc(ref, { alias, updatedAt: now });
          existing.alias = alias;
          existing.updatedAt = now;
        }
        return existing;
      }

      const docRef = await addDoc(usersCollection, {
        alias,
        dniRef,
        createdAt: now,
        updatedAt: now
      });

      return { userId: docRef.id, alias, dniRef, createdAt: now, updatedAt: now };
    }

    function savePredictions(data) {
      const userId = currentUser?.userId;
      if (!userId) return;
      predictionsCache = { ...data };
      const raw = localStorage.getItem('prodePredictions');
      const stored = raw ? JSON.parse(raw) : {};
      stored[userId] = predictionsCache;
      localStorage.setItem('prodePredictions', JSON.stringify(stored));
    }

    function loadPredictions() {
      if (Object.keys(predictionsCache).length) return predictionsCache;
      const raw = localStorage.getItem('prodePredictions');
      if (!raw || !currentUser) return {};
      const stored = JSON.parse(raw);
      predictionsCache = stored[currentUser.userId] || {};
      return predictionsCache;
    }

    async function loadUserPredictionsFromDb() {
      if (!currentUser) return {};
      await ensureAuth();
      const q = query(predictionsCollection, where('userId', '==', currentUser.userId));
      const snap = await getDocs(q);
      const loaded = {};
      snap.forEach(docSnap => {
        const data = docSnap.data();
        if (data.matchId) loaded[data.matchId] = data;
      });
      predictionsCache = loaded;
      savePredictions(predictionsCache);
      return predictionsCache;
    }

    async function persistPrediction(matchId, payload) {
      if (!currentUser) return;
      await ensureAuth();
      const now = new Date().toISOString();
      const docRef = doc(predictionsCollection, `${currentUser.userId}_${matchId}`);
      const data = {
        userId: currentUser.userId,
        matchId,
        timestamp: now,
        ...payload
      };
      predictionsCache[matchId] = data;
      savePredictions(predictionsCache);
      try {
        await setDoc(docRef, data, { merge: true });
      } catch (error) {
        console.error('No se pudo guardar el pron√≥stico en la base', error);
      }
    }

    async function loadUserRanking() {
      if (!currentUser) return null;
      await ensureAuth();
      const ref = doc(rankingCollection, currentUser.userId);
      const snap = await getDoc(ref);
      if (!snap.exists()) return null;
      return snap.data();
    }

    async function fetchRanking() {
      await ensureAuth();
      const q = query(rankingCollection, orderBy('puntosTotales', 'desc'));
      const snap = await getDocs(q);
      const rows = [];
      snap.forEach(docSnap => rows.push(docSnap.data()));
      return rows;
    }

    function toggleSection(target) {
      document.querySelectorAll('.section').forEach(sec => sec.classList.add('hidden'));
      document.querySelectorAll('.nav-card').forEach(card => card.classList.remove('active'));
      if (target === 'home') return;
      const el = document.getElementById(target);
      el?.classList.remove('hidden');
      if (target === 'stage1') renderStage1();
      if (target === 'stage2') renderStage2();
      if (target === 'scores') renderScores();
      if (target === 'ranking') renderRanking();
      el?.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }

    function renderBadges() {
      const stage1State = stageStatus.etapa1;
      const stage2State = stageStatus.etapa2;

      const badgeMap = {
        abierta: { className: 'badge-open', text: 'Abierta' },
        cerrada: { className: 'badge-closed', text: 'Cerrada' },
        bloqueada: { className: 'badge-blocked', text: 'Bloqueada' }
      };

      const b1 = badgeMap[stage1State];
      badgeStage1.className = `badge ${b1.className}`;
      badgeStage1.textContent = `Estado: ${b1.text}`;

      const b2 = badgeMap[stage2State];
      badgeStage2.className = `badge ${b2.className}`;
      badgeStage2.textContent = `Estado: ${b2.text}`;

      document.getElementById('stage1State').textContent = `Etapa 1: ${b1.text}`;
      document.getElementById('stage2State').textContent = `Etapa 2: ${b2.text}`;
    }

    function buildBranchSwitch(container, value, onChange) {
      container.innerHTML = '';
      ['FEM', 'MASC'].forEach(code => {
        const btn = document.createElement('button');
        btn.textContent = branchLabels[code];
        btn.className = value === code ? 'active' : '';
        btn.addEventListener('click', () => onChange(code));
        container.appendChild(btn);
      });
    }

    function renderStage1() {
      buildBranchSwitch(document.getElementById('branchSwitch1'), currentBranch1, val => {
        currentBranch1 = val;
        renderStage1();
      });

      stage1List.innerHTML = '';
      const predictions = loadPredictions();
      const branchMatches = stage1Matches.filter(m => m.rama === currentBranch1);
      const stageOpen = stageStatus.etapa1 === 'abierta';

      branchMatches.forEach(match => {
        const card = document.createElement('div');
        card.className = 'match-card';
        const locked = !stageOpen || match.estado !== 'pendiente';
        if (locked) card.classList.add('locked');

        card.innerHTML = `
          <div class="match-top">
            <div>${match.zona} ¬∑ ${match.cancha} ¬∑ ${match.hora}</div>
            <span class="ribbon">${match.estado}</span>
          </div>
          <div class="team-row">
            <span class="team-name">${match.equipo1}</span>
            <button class="select-btn" data-team="${match.equipo1}" ${locked ? 'disabled' : ''}>Elegir</button>
          </div>
          <div class="team-row">
            <span class="team-name">${match.equipo2}</span>
            <button class="select-btn" data-team="${match.equipo2}" ${locked ? 'disabled' : ''}>Elegir</button>
          </div>
          <div class="helper">${locked ? '<span class="locked-label">üîí No se puede modificar</span>' : 'Seleccion√° el ganador antes del inicio del partido.'}</div>
        `;

        const buttons = card.querySelectorAll('.select-btn');
        buttons.forEach(btn => {
          btn.addEventListener('click', async () => {
            predictions[match.matchId] = { rama: match.rama, etapa: 1, equipoPronosticadoGanador: btn.dataset.team };
            buttons.forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            await persistPrediction(match.matchId, predictions[match.matchId]);
            renderScores();
          });
        });

        const selected = predictions[match.matchId]?.equipoPronosticadoGanador;
        if (selected) {
          buttons.forEach(b => {
            if (b.dataset.team === selected) b.classList.add('selected');
          });
        }

        stage1List.appendChild(card);
      });
    }

    function resolveTeamName(ref, rama) {
      if (!ref) return '';
      const allRounds = stage2Rounds[rama];
      for (const round of Object.values(allRounds)) {
        const match = round.find(m => m.matchId === ref);
        if (match) {
          const predictions = loadPredictions();
          const prediction = predictions[ref]?.equipoPronosticadoGanador;
          const resolved = prediction || match.resultadoReal || `${match.label} ganador`;
          return resolved;
        }
      }
      return ref;
    }

    function renderStage2() {
      buildBranchSwitch(document.getElementById('branchSwitch2'), currentBranch2, val => {
        currentBranch2 = val;
        renderStage2();
      });

      stage2Content.innerHTML = '';
      const status = stageStatus.etapa2;
      if (status === 'bloqueada') {
        const notice = document.createElement('p');
        notice.className = 'notice';
        notice.textContent = 'Se habilita cuando termine la fase de grupos.';
        stage2Content.appendChild(notice);
        return;
      }

      const predictions = loadPredictions();
      const rounds = stage2Rounds[currentBranch2];
      Object.entries(rounds).forEach(([roundKey, matches]) => {
        if (!matches.length) return;
        const block = document.createElement('div');
        block.className = 'list';
        const title = document.createElement('h3');
        title.textContent = roundKey === 'Final' ? 'Final' : `Ronda ${roundKey}`;
        title.style.margin = '8px 0';
        stage2Content.appendChild(title);
        stage2Content.appendChild(block);

        matches.forEach(match => {
          const card = document.createElement('div');
          card.className = 'match-card';
          const editable = status === 'abierta' && match.estado === 'pendiente';
          if (!editable) card.classList.add('locked');

          const equipo1 = match.equipo1Ref ? resolveTeamName(match.equipo1Ref, currentBranch2) : match.equipo1;
          const equipo2 = match.equipo2Ref ? resolveTeamName(match.equipo2Ref, currentBranch2) : match.equipo2;

          card.innerHTML = `
            <div class="match-top">
              <div>${match.label} ¬∑ ${branchLabels[currentBranch2]}</div>
              <span class="ribbon">${match.estado}</span>
            </div>
            <div class="team-row">
              <span class="team-name">${equipo1}</span>
              <button class="select-btn" data-team="${equipo1}" ${editable ? '' : 'disabled'}>Gana</button>
            </div>
            <div class="team-row">
              <span class="team-name">${equipo2}</span>
              <button class="select-btn" data-team="${equipo2}" ${editable ? '' : 'disabled'}>Gana</button>
            </div>
            <div class="helper">${editable ? 'Eleg√≠ tu ganador para avanzar en el bracket.' : '<span class="locked-label">üîí No se puede modificar</span>'}</div>
          `;

          const buttons = card.querySelectorAll('.select-btn');
          buttons.forEach(btn => {
            btn.addEventListener('click', async () => {
              predictions[match.matchId] = { rama: currentBranch2, etapa: 2, ronda: match.ronda, equipoPronosticadoGanador: btn.dataset.team };
              buttons.forEach(b => b.classList.remove('selected'));
              btn.classList.add('selected');
              await persistPrediction(match.matchId, predictions[match.matchId]);
              renderStage2();
              renderScores();
            });
          });

          const selected = predictions[match.matchId]?.equipoPronosticadoGanador;
          if (selected) {
            buttons.forEach(b => {
              if (b.dataset.team === selected) b.classList.add('selected');
            });
          }

          block.appendChild(card);
        });
      });
    }

    async function renderScores() {
      if (!currentUser) return;
      const data = await loadUserRanking();
      const etapa1 = data?.puntosEtapa1 || 0;
      const etapa2 = data?.puntosEtapa2 || 0;
      const total = data?.puntosTotales || etapa1 + etapa2;
      document.getElementById('pointsStage1').textContent = `${etapa1} pts`;
      document.getElementById('pointsStage2').textContent = `${etapa2} pts`;
      document.getElementById('pointsTotal').textContent = `${total} pts`;
      renderRanking();
    }

    async function renderRanking() {
      const rankingList = document.getElementById('rankingList');
      rankingList.innerHTML = '<div class="helper">Cargando ranking...</div>';
      const rankingPositionEl = document.getElementById('rankingPosition');
      rankingPositionEl.textContent = '';

      const rows = await fetchRanking();
      rankingList.innerHTML = '';
      if (!rows.length) {
        rankingList.innerHTML = '<div class="helper">A√∫n no hay puntos cargados.</div>';
        return;
      }

      const myId = currentUser?.userId;
      rows.forEach((row, idx) => {
        const item = document.createElement('div');
        const isMe = myId && row.userId === myId;
        item.className = 'ranking-row' + (isMe ? ' me' : '');
        item.innerHTML = `
          <div class="label-muted">#${idx + 1}</div>
          <div>${row.alias || 'Alias'}</div>
          <div><strong>${row.puntosTotales || 0} pts</strong></div>
        `;
        rankingList.appendChild(item);
        if (isMe) {
          rankingPositionEl.textContent = `Puesto #${idx + 1}`;
        }
      });
    }

    function initNavigation() {
      document.querySelectorAll('[data-target]').forEach(el => {
        el.addEventListener('click', () => {
          toggleSection(el.dataset.target);
        });
      });
    }

    const createUserButton = document.getElementById('createUser');
    createUserButton.addEventListener('click', async () => {
      const alias = document.getElementById('aliasInput').value.trim();
      const dni = document.getElementById('dniInput').value.trim();
      if (!alias || !dni) {
        alert('Complet√° alias y DNI para continuar.');
        return;
      }

      const originalLabel = createUserButton.textContent;
      createUserButton.disabled = true;
      createUserButton.textContent = 'Guardando...';

      try {
        const userRecord = await upsertUser(alias, dni);
        currentUser = userRecord;
        saveUser(currentUser);
        document.getElementById('loginPanel').classList.add('hidden');
        document.getElementById('homeSection').classList.remove('hidden');
        document.getElementById('userAlias').textContent = userRecord.alias;
        renderBadges();
        await loadUserPredictionsFromDb();
        renderStage1();
        renderStage2();
        await renderScores();
      } catch (error) {
        console.error('Error guardando usuario Prode', error);
        alert('No se pudo guardar tu usuario. Intent√° de nuevo.');
      } finally {
        createUserButton.disabled = false;
        createUserButton.textContent = originalLabel;
      }
    });

    async function bootstrap() {
      initNavigation();
      currentUser = loadUser();
      if (currentUser) {
        document.getElementById('loginPanel').classList.add('hidden');
        document.getElementById('homeSection').classList.remove('hidden');
        document.getElementById('userAlias').textContent = currentUser.alias;
        await loadUserPredictionsFromDb();
      }
      renderBadges();
      attachStage1Listener();
      attachStage2Listener();
      renderStage1();
      await renderScores();
      await renderRanking();
    }

    bootstrap();
  </script>
</body>
</html>
